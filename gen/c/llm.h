// Generated by `wit-bindgen` 0.33.0. DO NOT EDIT!
#ifndef __BINDINGS_LLM_H
#define __BINDINGS_LLM_H
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

typedef struct llm_string_t {
  uint8_t*ptr;
  size_t len;
} llm_string_t;

// A time and date in seconds plus nanoseconds.
typedef struct wasi_clocks_wall_clock_datetime_t {
  uint64_t   seconds;
  uint32_t   nanoseconds;
} wasi_clocks_wall_clock_datetime_t;

typedef struct wasi_io_poll_own_pollable_t {
  int32_t __handle;
} wasi_io_poll_own_pollable_t;

typedef struct wasi_io_poll_borrow_pollable_t {
  int32_t __handle;
} wasi_io_poll_borrow_pollable_t;

typedef struct {
  wasi_io_poll_borrow_pollable_t *ptr;
  size_t len;
} wasi_io_poll_list_borrow_pollable_t;

typedef struct {
  uint32_t *ptr;
  size_t len;
} llm_list_u32_t;

// An instant in time, in nanoseconds. An instant is relative to an
// unspecified initial value, and can only be compared to instances from
// the same monotonic-clock.
typedef uint64_t wasi_clocks_monotonic_clock_instant_t;

// A duration of time, in nanoseconds.
typedef uint64_t wasi_clocks_monotonic_clock_duration_t;

typedef wasi_io_poll_own_pollable_t wasi_clocks_monotonic_clock_own_pollable_t;

typedef struct {
  uint8_t *ptr;
  size_t len;
} llm_list_u8_t;

typedef struct wasi_io_error_own_error_t {
  int32_t __handle;
} wasi_io_error_own_error_t;

typedef struct wasi_io_error_borrow_error_t {
  int32_t __handle;
} wasi_io_error_borrow_error_t;

typedef wasi_io_error_own_error_t wasi_io_streams_own_error_t;

// An error for input-stream and output-stream operations.
typedef struct wasi_io_streams_stream_error_t {
  uint8_t tag;
  union {
    wasi_io_streams_own_error_t     last_operation_failed;
  } val;
} wasi_io_streams_stream_error_t;

// The last operation (a write or flush) failed before completion.
// 
// More information is available in the `error` payload.
#define WASI_IO_STREAMS_STREAM_ERROR_LAST_OPERATION_FAILED 0
// The stream is closed: no more input will be accepted by the
// stream. A closed output-stream will return this error on all
// future operations.
#define WASI_IO_STREAMS_STREAM_ERROR_CLOSED 1

typedef struct wasi_io_streams_own_input_stream_t {
  int32_t __handle;
} wasi_io_streams_own_input_stream_t;

typedef struct wasi_io_streams_borrow_input_stream_t {
  int32_t __handle;
} wasi_io_streams_borrow_input_stream_t;

typedef struct wasi_io_streams_own_output_stream_t {
  int32_t __handle;
} wasi_io_streams_own_output_stream_t;

typedef struct wasi_io_streams_borrow_output_stream_t {
  int32_t __handle;
} wasi_io_streams_borrow_output_stream_t;

typedef struct {
  bool is_err;
  union {
    llm_list_u8_t ok;
    wasi_io_streams_stream_error_t err;
  } val;
} wasi_io_streams_result_list_u8_stream_error_t;

typedef struct {
  bool is_err;
  union {
    uint64_t ok;
    wasi_io_streams_stream_error_t err;
  } val;
} wasi_io_streams_result_u64_stream_error_t;

typedef wasi_io_poll_own_pollable_t wasi_io_streams_own_pollable_t;

typedef struct {
  bool is_err;
  union {
    wasi_io_streams_stream_error_t err;
  } val;
} wasi_io_streams_result_void_stream_error_t;

typedef wasi_clocks_wall_clock_datetime_t wasi_filesystem_types_datetime_t;

// File size or length of a region within a file.
typedef uint64_t wasi_filesystem_types_filesize_t;

// The type of a filesystem object referenced by a descriptor.
// 
// Note: This was called `filetype` in earlier versions of WASI.
typedef uint8_t wasi_filesystem_types_descriptor_type_t;

// The type of the descriptor or file is unknown or is different from
// any of the other types specified.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_UNKNOWN 0
// The descriptor refers to a block device inode.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_BLOCK_DEVICE 1
// The descriptor refers to a character device inode.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_CHARACTER_DEVICE 2
// The descriptor refers to a directory inode.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_DIRECTORY 3
// The descriptor refers to a named pipe.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_FIFO 4
// The file refers to a symbolic link inode.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_SYMBOLIC_LINK 5
// The descriptor refers to a regular file inode.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_REGULAR_FILE 6
// The descriptor refers to a socket.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_TYPE_SOCKET 7

// Descriptor flags.
// 
// Note: This was called `fdflags` in earlier versions of WASI.
typedef uint8_t wasi_filesystem_types_descriptor_flags_t;

// Read mode: Data can be read.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_FLAGS_READ (1 << 0)
// Write mode: Data can be written to.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_FLAGS_WRITE (1 << 1)
// Request that writes be performed according to synchronized I/O file
// integrity completion. The data stored in the file and the file's
// metadata are synchronized. This is similar to `O_SYNC` in POSIX.
// 
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_FLAGS_FILE_INTEGRITY_SYNC (1 << 2)
// Request that writes be performed according to synchronized I/O data
// integrity completion. Only the data stored in the file is
// synchronized. This is similar to `O_DSYNC` in POSIX.
// 
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_FLAGS_DATA_INTEGRITY_SYNC (1 << 3)
// Requests that reads be performed at the same level of integrity
// requested for writes. This is similar to `O_RSYNC` in POSIX.
// 
// The precise semantics of this operation have not yet been defined for
// WASI. At this time, it should be interpreted as a request, and not a
// requirement.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_FLAGS_REQUESTED_WRITE_SYNC (1 << 4)
// Mutating directories mode: Directory contents may be mutated.
// 
// When this flag is unset on a descriptor, operations using the
// descriptor which would create, rename, delete, modify the data or
// metadata of filesystem objects, or obtain another handle which
// would permit any of those, shall fail with `error-code::read-only` if
// they would otherwise succeed.
// 
// This may only be set on directories.
#define WASI_FILESYSTEM_TYPES_DESCRIPTOR_FLAGS_MUTATE_DIRECTORY (1 << 5)

// Flags determining the method of how paths are resolved.
typedef uint8_t wasi_filesystem_types_path_flags_t;

// As long as the resolved path corresponds to a symbolic link, it is
// expanded.
#define WASI_FILESYSTEM_TYPES_PATH_FLAGS_SYMLINK_FOLLOW (1 << 0)

// Open flags used by `open-at`.
typedef uint8_t wasi_filesystem_types_open_flags_t;

// Create file if it does not exist, similar to `O_CREAT` in POSIX.
#define WASI_FILESYSTEM_TYPES_OPEN_FLAGS_CREATE (1 << 0)
// Fail if not a directory, similar to `O_DIRECTORY` in POSIX.
#define WASI_FILESYSTEM_TYPES_OPEN_FLAGS_DIRECTORY (1 << 1)
// Fail if file already exists, similar to `O_EXCL` in POSIX.
#define WASI_FILESYSTEM_TYPES_OPEN_FLAGS_EXCLUSIVE (1 << 2)
// Truncate file to size 0, similar to `O_TRUNC` in POSIX.
#define WASI_FILESYSTEM_TYPES_OPEN_FLAGS_TRUNCATE (1 << 3)

// Number of hard links to an inode.
typedef uint64_t wasi_filesystem_types_link_count_t;

typedef struct {
  bool is_some;
  wasi_filesystem_types_datetime_t val;
} wasi_filesystem_types_option_datetime_t;

// File attributes.
// 
// Note: This was called `filestat` in earlier versions of WASI.
typedef struct wasi_filesystem_types_descriptor_stat_t {
  // File type.
  wasi_filesystem_types_descriptor_type_t   type;
  // Number of hard links to the file.
  wasi_filesystem_types_link_count_t   link_count;
  // For regular files, the file size in bytes. For symbolic links, the
  // length in bytes of the pathname contained in the symbolic link.
  wasi_filesystem_types_filesize_t   size;
  // Last data access timestamp.
  // 
  // If the `option` is none, the platform doesn't maintain an access
  // timestamp for this file.
  wasi_filesystem_types_option_datetime_t   data_access_timestamp;
  // Last data modification timestamp.
  // 
  // If the `option` is none, the platform doesn't maintain a
  // modification timestamp for this file.
  wasi_filesystem_types_option_datetime_t   data_modification_timestamp;
  // Last file status-change timestamp.
  // 
  // If the `option` is none, the platform doesn't maintain a
  // status-change timestamp for this file.
  wasi_filesystem_types_option_datetime_t   status_change_timestamp;
} wasi_filesystem_types_descriptor_stat_t;

// When setting a timestamp, this gives the value to set it to.
typedef struct wasi_filesystem_types_new_timestamp_t {
  uint8_t tag;
  union {
    wasi_filesystem_types_datetime_t     timestamp;
  } val;
} wasi_filesystem_types_new_timestamp_t;

// Leave the timestamp set to its previous value.
#define WASI_FILESYSTEM_TYPES_NEW_TIMESTAMP_NO_CHANGE 0
// Set the timestamp to the current time of the system clock associated
// with the filesystem.
#define WASI_FILESYSTEM_TYPES_NEW_TIMESTAMP_NOW 1
// Set the timestamp to the given value.
#define WASI_FILESYSTEM_TYPES_NEW_TIMESTAMP_TIMESTAMP 2

// A directory entry.
typedef struct wasi_filesystem_types_directory_entry_t {
  // The type of the file referred to by this directory entry.
  wasi_filesystem_types_descriptor_type_t   type;
  // The name of the object.
  llm_string_t   name;
} wasi_filesystem_types_directory_entry_t;

// Error codes returned by functions, similar to `errno` in POSIX.
// Not all of these error codes are returned by the functions provided by this
// API; some are used in higher-level library layers, and others are provided
// merely for alignment with POSIX.
typedef uint8_t wasi_filesystem_types_error_code_t;

// Permission denied, similar to `EACCES` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_ACCESS 0
// Resource unavailable, or operation would block, similar to `EAGAIN` and `EWOULDBLOCK` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_WOULD_BLOCK 1
// Connection already in progress, similar to `EALREADY` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_ALREADY 2
// Bad descriptor, similar to `EBADF` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_BAD_DESCRIPTOR 3
// Device or resource busy, similar to `EBUSY` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_BUSY 4
// Resource deadlock would occur, similar to `EDEADLK` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_DEADLOCK 5
// Storage quota exceeded, similar to `EDQUOT` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_QUOTA 6
// File exists, similar to `EEXIST` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_EXIST 7
// File too large, similar to `EFBIG` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_FILE_TOO_LARGE 8
// Illegal byte sequence, similar to `EILSEQ` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_ILLEGAL_BYTE_SEQUENCE 9
// Operation in progress, similar to `EINPROGRESS` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_IN_PROGRESS 10
// Interrupted function, similar to `EINTR` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_INTERRUPTED 11
// Invalid argument, similar to `EINVAL` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_INVALID 12
// I/O error, similar to `EIO` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_IO 13
// Is a directory, similar to `EISDIR` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_IS_DIRECTORY 14
// Too many levels of symbolic links, similar to `ELOOP` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_LOOP 15
// Too many links, similar to `EMLINK` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_TOO_MANY_LINKS 16
// Message too large, similar to `EMSGSIZE` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_MESSAGE_SIZE 17
// Filename too long, similar to `ENAMETOOLONG` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NAME_TOO_LONG 18
// No such device, similar to `ENODEV` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NO_DEVICE 19
// No such file or directory, similar to `ENOENT` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NO_ENTRY 20
// No locks available, similar to `ENOLCK` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NO_LOCK 21
// Not enough space, similar to `ENOMEM` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_INSUFFICIENT_MEMORY 22
// No space left on device, similar to `ENOSPC` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_INSUFFICIENT_SPACE 23
// Not a directory or a symbolic link to a directory, similar to `ENOTDIR` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NOT_DIRECTORY 24
// Directory not empty, similar to `ENOTEMPTY` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NOT_EMPTY 25
// State not recoverable, similar to `ENOTRECOVERABLE` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NOT_RECOVERABLE 26
// Not supported, similar to `ENOTSUP` and `ENOSYS` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_UNSUPPORTED 27
// Inappropriate I/O control operation, similar to `ENOTTY` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NO_TTY 28
// No such device or address, similar to `ENXIO` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NO_SUCH_DEVICE 29
// Value too large to be stored in data type, similar to `EOVERFLOW` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_OVERFLOW 30
// Operation not permitted, similar to `EPERM` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_NOT_PERMITTED 31
// Broken pipe, similar to `EPIPE` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_PIPE 32
// Read-only file system, similar to `EROFS` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_READ_ONLY 33
// Invalid seek, similar to `ESPIPE` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_INVALID_SEEK 34
// Text file busy, similar to `ETXTBSY` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_TEXT_FILE_BUSY 35
// Cross-device link, similar to `EXDEV` in POSIX.
#define WASI_FILESYSTEM_TYPES_ERROR_CODE_CROSS_DEVICE 36

// File or memory access pattern advisory information.
typedef uint8_t wasi_filesystem_types_advice_t;

// The application has no advice to give on its behavior with respect
// to the specified data.
#define WASI_FILESYSTEM_TYPES_ADVICE_NORMAL 0
// The application expects to access the specified data sequentially
// from lower offsets to higher offsets.
#define WASI_FILESYSTEM_TYPES_ADVICE_SEQUENTIAL 1
// The application expects to access the specified data in a random
// order.
#define WASI_FILESYSTEM_TYPES_ADVICE_RANDOM 2
// The application expects to access the specified data in the near
// future.
#define WASI_FILESYSTEM_TYPES_ADVICE_WILL_NEED 3
// The application expects that it will not access the specified data
// in the near future.
#define WASI_FILESYSTEM_TYPES_ADVICE_DONT_NEED 4
// The application expects to access the specified data once and then
// not reuse it thereafter.
#define WASI_FILESYSTEM_TYPES_ADVICE_NO_REUSE 5

// A 128-bit hash value, split into parts because wasm doesn't have a
// 128-bit integer type.
typedef struct wasi_filesystem_types_metadata_hash_value_t {
  // 64 bits of a 128-bit hash value.
  uint64_t   lower;
  // Another 64 bits of a 128-bit hash value.
  uint64_t   upper;
} wasi_filesystem_types_metadata_hash_value_t;

typedef struct wasi_filesystem_types_own_descriptor_t {
  int32_t __handle;
} wasi_filesystem_types_own_descriptor_t;

typedef struct wasi_filesystem_types_borrow_descriptor_t {
  int32_t __handle;
} wasi_filesystem_types_borrow_descriptor_t;

typedef struct wasi_filesystem_types_own_directory_entry_stream_t {
  int32_t __handle;
} wasi_filesystem_types_own_directory_entry_stream_t;

typedef struct wasi_filesystem_types_borrow_directory_entry_stream_t {
  int32_t __handle;
} wasi_filesystem_types_borrow_directory_entry_stream_t;

typedef wasi_io_streams_own_input_stream_t wasi_filesystem_types_own_input_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_own_input_stream_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_own_input_stream_error_code_t;

typedef wasi_io_streams_own_output_stream_t wasi_filesystem_types_own_output_stream_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_own_output_stream_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_own_output_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_void_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_descriptor_flags_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_descriptor_flags_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_descriptor_type_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_descriptor_type_error_code_t;

typedef struct {
  llm_list_u8_t f0;
  bool f1;
} llm_tuple2_list_u8_bool_t;

typedef struct {
  bool is_err;
  union {
    llm_tuple2_list_u8_bool_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_tuple2_list_u8_bool_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_filesize_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_filesize_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_own_directory_entry_stream_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_own_directory_entry_stream_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_descriptor_stat_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_descriptor_stat_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_own_descriptor_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_own_descriptor_error_code_t;

typedef struct {
  bool is_err;
  union {
    llm_string_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_string_error_code_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_metadata_hash_value_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_metadata_hash_value_error_code_t;

typedef struct {
  bool is_some;
  wasi_filesystem_types_directory_entry_t val;
} wasi_filesystem_types_option_directory_entry_t;

typedef struct {
  bool is_err;
  union {
    wasi_filesystem_types_option_directory_entry_t ok;
    wasi_filesystem_types_error_code_t err;
  } val;
} wasi_filesystem_types_result_option_directory_entry_error_code_t;

typedef wasi_io_error_borrow_error_t wasi_filesystem_types_borrow_error_t;

typedef struct {
  bool is_some;
  wasi_filesystem_types_error_code_t val;
} wasi_filesystem_types_option_error_code_t;

typedef wasi_filesystem_types_own_descriptor_t wasi_filesystem_preopens_own_descriptor_t;

typedef struct {
  wasi_filesystem_preopens_own_descriptor_t f0;
  llm_string_t f1;
} wasi_filesystem_preopens_tuple2_own_descriptor_string_t;

typedef struct {
  wasi_filesystem_preopens_tuple2_own_descriptor_string_t *ptr;
  size_t len;
} wasi_filesystem_preopens_list_tuple2_own_descriptor_string_t;

typedef wasi_io_streams_own_output_stream_t wasi_cli_stdout_own_output_stream_t;

typedef wasi_io_streams_own_output_stream_t wasi_cli_stderr_own_output_stream_t;

typedef wasi_io_streams_own_input_stream_t wasi_cli_stdin_own_input_stream_t;

typedef struct {
  llm_string_t f0;
  llm_string_t f1;
} llm_tuple2_string_string_t;

typedef struct {
  llm_tuple2_string_string_t *ptr;
  size_t len;
} llm_list_tuple2_string_string_t;

typedef struct {
  llm_string_t *ptr;
  size_t len;
} llm_list_string_t;

typedef struct {
  bool is_some;
  llm_string_t val;
} llm_option_string_t;

// The dimensions of a tensor.
// 
// The array length matches the tensor rank and each element in the array describes the size of
// each dimension
typedef struct wasi_nn_tensor_tensor_dimensions_t {
  uint32_t   *ptr;
  size_t len;
} wasi_nn_tensor_tensor_dimensions_t;

// The type of the elements in a tensor.
typedef uint8_t wasi_nn_tensor_tensor_type_t;

#define WASI_NN_TENSOR_TENSOR_TYPE_FP16 0
#define WASI_NN_TENSOR_TENSOR_TYPE_FP32 1
#define WASI_NN_TENSOR_TENSOR_TYPE_FP64 2
#define WASI_NN_TENSOR_TENSOR_TYPE_BF16 3
#define WASI_NN_TENSOR_TENSOR_TYPE_U8 4
#define WASI_NN_TENSOR_TENSOR_TYPE_I32 5
#define WASI_NN_TENSOR_TENSOR_TYPE_I64 6

// The tensor data.
// 
// Initially conceived as a sparse representation, each empty cell would be filled with zeros
// and the array length must match the product of all of the dimensions and the number of bytes
// in the type (e.g., a 2x2 tensor with 4-byte f32 elements would have a data array of length
// 16). Naturally, this representation requires some knowledge of how to lay out data in
// memory--e.g., using row-major ordering--and could perhaps be improved.
typedef struct wasi_nn_tensor_tensor_data_t {
  uint8_t   *ptr;
  size_t len;
} wasi_nn_tensor_tensor_data_t;

typedef struct wasi_nn_tensor_own_tensor_t {
  int32_t __handle;
} wasi_nn_tensor_own_tensor_t;

typedef struct wasi_nn_tensor_borrow_tensor_t {
  int32_t __handle;
} wasi_nn_tensor_borrow_tensor_t;

typedef uint8_t wasi_nn_errors_error_code_t;

// Caller module passed an invalid argument.
#define WASI_NN_ERRORS_ERROR_CODE_INVALID_ARGUMENT 0
// Invalid encoding.
#define WASI_NN_ERRORS_ERROR_CODE_INVALID_ENCODING 1
// The operation timed out.
#define WASI_NN_ERRORS_ERROR_CODE_TIMEOUT 2
// Runtime Error.
#define WASI_NN_ERRORS_ERROR_CODE_RUNTIME_ERROR 3
// Unsupported operation.
#define WASI_NN_ERRORS_ERROR_CODE_UNSUPPORTED_OPERATION 4
// Graph is too large.
#define WASI_NN_ERRORS_ERROR_CODE_TOO_LARGE 5
// Graph not found.
#define WASI_NN_ERRORS_ERROR_CODE_NOT_FOUND 6
// The operation is insecure or has insufficient privilege to be performed.
// e.g., cannot access a hardware feature requested
#define WASI_NN_ERRORS_ERROR_CODE_SECURITY 7
// The operation failed for an unspecified reason.
#define WASI_NN_ERRORS_ERROR_CODE_UNKNOWN 8

typedef struct wasi_nn_errors_own_error_t {
  int32_t __handle;
} wasi_nn_errors_own_error_t;

typedef struct wasi_nn_errors_borrow_error_t {
  int32_t __handle;
} wasi_nn_errors_borrow_error_t;

typedef wasi_nn_tensor_tensor_data_t wasi_nn_inference_tensor_data_t;

typedef struct wasi_nn_inference_own_graph_execution_context_t {
  int32_t __handle;
} wasi_nn_inference_own_graph_execution_context_t;

typedef struct wasi_nn_inference_borrow_graph_execution_context_t {
  int32_t __handle;
} wasi_nn_inference_borrow_graph_execution_context_t;

typedef wasi_nn_tensor_own_tensor_t wasi_nn_inference_own_tensor_t;

typedef wasi_nn_errors_own_error_t wasi_nn_inference_own_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_nn_inference_own_error_t err;
  } val;
} wasi_nn_inference_result_void_own_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_nn_inference_own_tensor_t ok;
    wasi_nn_inference_own_error_t err;
  } val;
} wasi_nn_inference_result_own_tensor_own_error_t;

typedef struct wasi_nn_graph_own_graph_t {
  int32_t __handle;
} wasi_nn_graph_own_graph_t;

typedef struct wasi_nn_graph_borrow_graph_t {
  int32_t __handle;
} wasi_nn_graph_borrow_graph_t;

// Describes the encoding of the graph. This allows the API to be implemented by various
// backends that encode (i.e., serialize) their graph IR with different formats.
typedef uint8_t wasi_nn_graph_graph_encoding_t;

#define WASI_NN_GRAPH_GRAPH_ENCODING_OPENVINO 0
#define WASI_NN_GRAPH_GRAPH_ENCODING_ONNX 1
#define WASI_NN_GRAPH_GRAPH_ENCODING_TENSORFLOW 2
#define WASI_NN_GRAPH_GRAPH_ENCODING_PYTORCH 3
#define WASI_NN_GRAPH_GRAPH_ENCODING_TENSORFLOWLITE 4
#define WASI_NN_GRAPH_GRAPH_ENCODING_GGML 5
#define WASI_NN_GRAPH_GRAPH_ENCODING_AUTODETECT 6

// Define where the graph should be executed.
typedef uint8_t wasi_nn_graph_execution_target_t;

#define WASI_NN_GRAPH_EXECUTION_TARGET_CPU 0
#define WASI_NN_GRAPH_EXECUTION_TARGET_GPU 1
#define WASI_NN_GRAPH_EXECUTION_TARGET_TPU 2

// The graph initialization data.
// 
// This gets bundled up into an array of buffers because implementing backends may encode their
// graph IR in parts (e.g., OpenVINO stores its IR and weights separately).
typedef struct wasi_nn_graph_graph_builder_t {
  uint8_t   *ptr;
  size_t len;
} wasi_nn_graph_graph_builder_t;

typedef wasi_nn_inference_own_graph_execution_context_t wasi_nn_graph_own_graph_execution_context_t;

typedef wasi_nn_errors_own_error_t wasi_nn_graph_own_error_t;

typedef struct {
  bool is_err;
  union {
    wasi_nn_graph_own_graph_execution_context_t ok;
    wasi_nn_graph_own_error_t err;
  } val;
} wasi_nn_graph_result_own_graph_execution_context_own_error_t;

typedef struct {
  wasi_nn_graph_graph_builder_t *ptr;
  size_t len;
} llm_list_graph_builder_t;

typedef struct {
  bool is_err;
  union {
    wasi_nn_graph_own_graph_t ok;
    wasi_nn_graph_own_error_t err;
  } val;
} wasi_nn_graph_result_own_graph_own_error_t;

typedef struct {
  bool is_err;
} exports_wasi_cli_run_result_void_void_t;

// Imported Functions from `wasi:clocks/wall-clock@0.2.1`
// Read the current value of the clock.
// 
// This clock is not monotonic, therefore calling this function repeatedly
// will not necessarily produce a sequence of non-decreasing values.
// 
// The returned timestamps represent the number of seconds since
// 1970-01-01T00:00:00Z, also known as [POSIX's Seconds Since the Epoch],
// also known as [Unix Time].
// 
// The nanoseconds field of the output is always less than 1000000000.
// 
// [POSIX's Seconds Since the Epoch]: https://pubs.opengroup.org/onlinepubs/9699919799/xrat/V4_xbd_chap04.html#tag_21_04_16
// [Unix Time]: https://en.wikipedia.org/wiki/Unix_time
extern void wasi_clocks_wall_clock_now(wasi_clocks_wall_clock_datetime_t *ret);
// Query the resolution of the clock.
// 
// The nanoseconds field of the output is always less than 1000000000.
extern void wasi_clocks_wall_clock_resolution(wasi_clocks_wall_clock_datetime_t *ret);

// Imported Functions from `wasi:io/poll@0.2.1`
// Return the readiness of a pollable. This function never blocks.
// 
// Returns `true` when the pollable is ready, and `false` otherwise.
extern bool wasi_io_poll_method_pollable_ready(wasi_io_poll_borrow_pollable_t self);
// `block` returns immediately if the pollable is ready, and otherwise
// blocks until ready.
// 
// This function is equivalent to calling `poll.poll` on a list
// containing only this pollable.
extern void wasi_io_poll_method_pollable_block(wasi_io_poll_borrow_pollable_t self);
// Poll for completion on a set of pollables.
// 
// This function takes a list of pollables, which identify I/O sources of
// interest, and waits until one or more of the events is ready for I/O.
// 
// The result `list<u32>` contains one or more indices of handles in the
// argument list that is ready for I/O.
// 
// This function traps if either:
// - the list is empty, or:
// - the list contains more elements than can be indexed with a `u32` value.
// 
// A timeout can be implemented by adding a pollable from the
// wasi-clocks API to the list.
// 
// This function does not return a `result`; polling in itself does not
// do any I/O so it doesn't fail. If any of the I/O sources identified by
// the pollables has an error, it is indicated by marking the source as
// being ready for I/O.
extern void wasi_io_poll_poll(wasi_io_poll_list_borrow_pollable_t *in, llm_list_u32_t *ret);

// Imported Functions from `wasi:clocks/monotonic-clock@0.2.1`
// Read the current value of the clock.
// 
// The clock is monotonic, therefore calling this function repeatedly will
// produce a sequence of non-decreasing values.
extern wasi_clocks_monotonic_clock_instant_t wasi_clocks_monotonic_clock_now(void);
// Query the resolution of the clock. Returns the duration of time
// corresponding to a clock tick.
extern wasi_clocks_monotonic_clock_duration_t wasi_clocks_monotonic_clock_resolution(void);
// Create a `pollable` which will resolve once the specified instant
// has occurred.
extern wasi_clocks_monotonic_clock_own_pollable_t wasi_clocks_monotonic_clock_subscribe_instant(wasi_clocks_monotonic_clock_instant_t when);
// Create a `pollable` that will resolve after the specified duration has
// elapsed from the time this function is invoked.
extern wasi_clocks_monotonic_clock_own_pollable_t wasi_clocks_monotonic_clock_subscribe_duration(wasi_clocks_monotonic_clock_duration_t when);

// Imported Functions from `wasi:random/random@0.2.1`
// Return `len` cryptographically-secure random or pseudo-random bytes.
// 
// This function must produce data at least as cryptographically secure and
// fast as an adequately seeded cryptographically-secure pseudo-random
// number generator (CSPRNG). It must not block, from the perspective of
// the calling program, under any circumstances, including on the first
// request and on requests for numbers of bytes. The returned data must
// always be unpredictable.
// 
// This function must always return fresh data. Deterministic environments
// must omit this function, rather than implementing it with deterministic
// data.
extern void wasi_random_random_get_random_bytes(uint64_t len, llm_list_u8_t *ret);
// Return a cryptographically-secure random or pseudo-random `u64` value.
// 
// This function returns the same type of data as `get-random-bytes`,
// represented as a `u64`.
extern uint64_t wasi_random_random_get_random_u64(void);

// Imported Functions from `wasi:io/error@0.2.1`
// Returns a string that is suitable to assist humans in debugging
// this error.
// 
// WARNING: The returned string should not be consumed mechanically!
// It may change across platforms, hosts, or other implementation
// details. Parsing this string is a major platform-compatibility
// hazard.
extern void wasi_io_error_method_error_to_debug_string(wasi_io_error_borrow_error_t self, llm_string_t *ret);

// Imported Functions from `wasi:io/streams@0.2.1`
// Perform a non-blocking read from the stream.
// 
// When the source of a `read` is binary data, the bytes from the source
// are returned verbatim. When the source of a `read` is known to the
// implementation to be text, bytes containing the UTF-8 encoding of the
// text are returned.
// 
// This function returns a list of bytes containing the read data,
// when successful. The returned list will contain up to `len` bytes;
// it may return fewer than requested, but not more. The list is
// empty when no bytes are available for reading at this time. The
// pollable given by `subscribe` will be ready when more bytes are
// available.
// 
// This function fails with a `stream-error` when the operation
// encounters an error, giving `last-operation-failed`, or when the
// stream is closed, giving `closed`.
// 
// When the caller gives a `len` of 0, it represents a request to
// read 0 bytes. If the stream is still open, this call should
// succeed and return an empty list, or otherwise fail with `closed`.
// 
// The `len` parameter is a `u64`, which could represent a list of u8 which
// is not possible to allocate in wasm32, or not desirable to allocate as
// as a return value by the callee. The callee may return a list of bytes
// less than `len` in size while more bytes are available for reading.
extern bool wasi_io_streams_method_input_stream_read(wasi_io_streams_borrow_input_stream_t self, uint64_t len, llm_list_u8_t *ret, wasi_io_streams_stream_error_t *err);
// Read bytes from a stream, after blocking until at least one byte can
// be read. Except for blocking, behavior is identical to `read`.
extern bool wasi_io_streams_method_input_stream_blocking_read(wasi_io_streams_borrow_input_stream_t self, uint64_t len, llm_list_u8_t *ret, wasi_io_streams_stream_error_t *err);
// Skip bytes from a stream. Returns number of bytes skipped.
// 
// Behaves identical to `read`, except instead of returning a list
// of bytes, returns the number of bytes consumed from the stream.
extern bool wasi_io_streams_method_input_stream_skip(wasi_io_streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret, wasi_io_streams_stream_error_t *err);
// Skip bytes from a stream, after blocking until at least one byte
// can be skipped. Except for blocking behavior, identical to `skip`.
extern bool wasi_io_streams_method_input_stream_blocking_skip(wasi_io_streams_borrow_input_stream_t self, uint64_t len, uint64_t *ret, wasi_io_streams_stream_error_t *err);
// Create a `pollable` which will resolve once either the specified stream
// has bytes available to read or the other end of the stream has been
// closed.
// The created `pollable` is a child resource of the `input-stream`.
// Implementations may trap if the `input-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
extern wasi_io_streams_own_pollable_t wasi_io_streams_method_input_stream_subscribe(wasi_io_streams_borrow_input_stream_t self);
// Check readiness for writing. This function never blocks.
// 
// Returns the number of bytes permitted for the next call to `write`,
// or an error. Calling `write` with more bytes than this function has
// permitted will trap.
// 
// When this function returns 0 bytes, the `subscribe` pollable will
// become ready when this function will report at least 1 byte, or an
// error.
extern bool wasi_io_streams_method_output_stream_check_write(wasi_io_streams_borrow_output_stream_t self, uint64_t *ret, wasi_io_streams_stream_error_t *err);
// Perform a write. This function never blocks.
// 
// When the destination of a `write` is binary data, the bytes from
// `contents` are written verbatim. When the destination of a `write` is
// known to the implementation to be text, the bytes of `contents` are
// transcoded from UTF-8 into the encoding of the destination and then
// written.
// 
// Precondition: check-write gave permit of Ok(n) and contents has a
// length of less than or equal to n. Otherwise, this function will trap.
// 
// returns Err(closed) without writing if the stream has closed since
// the last call to check-write provided a permit.
extern bool wasi_io_streams_method_output_stream_write(wasi_io_streams_borrow_output_stream_t self, llm_list_u8_t *contents, wasi_io_streams_stream_error_t *err);
// Perform a write of up to 4096 bytes, and then flush the stream. Block
// until all of these operations are complete, or an error occurs.
// 
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write`, and `flush`, and is implemented with the
// following pseudo-code:
// 
// ```text
// let pollable = this.subscribe();
// while !contents.is_empty() {
// // Wait for the stream to become writable
// pollable.block();
// let Ok(n) = this.check-write(); // eliding error handling
// let len = min(n, contents.len());
// let (chunk, rest) = contents.split_at(len);
// this.write(chunk  );            // eliding error handling
// contents = rest;
// }
// this.flush();
// // Wait for completion of `flush`
// pollable.block();
// // Check for any errors that arose during `flush`
// let _ = this.check-write();         // eliding error handling
// ```
extern bool wasi_io_streams_method_output_stream_blocking_write_and_flush(wasi_io_streams_borrow_output_stream_t self, llm_list_u8_t *contents, wasi_io_streams_stream_error_t *err);
// Request to flush buffered output. This function never blocks.
// 
// This tells the output-stream that the caller intends any buffered
// output to be flushed. the output which is expected to be flushed
// is all that has been passed to `write` prior to this call.
// 
// Upon calling this function, the `output-stream` will not accept any
// writes (`check-write` will return `ok(0)`) until the flush has
// completed. The `subscribe` pollable will become ready when the
// flush has completed and the stream can accept more writes.
extern bool wasi_io_streams_method_output_stream_flush(wasi_io_streams_borrow_output_stream_t self, wasi_io_streams_stream_error_t *err);
// Request to flush buffered output, and block until flush completes
// and stream is ready for writing again.
extern bool wasi_io_streams_method_output_stream_blocking_flush(wasi_io_streams_borrow_output_stream_t self, wasi_io_streams_stream_error_t *err);
// Create a `pollable` which will resolve once the output-stream
// is ready for more writing, or an error has occurred. When this
// pollable is ready, `check-write` will return `ok(n)` with n>0, or an
// error.
// 
// If the stream is closed, this pollable is always ready immediately.
// 
// The created `pollable` is a child resource of the `output-stream`.
// Implementations may trap if the `output-stream` is dropped before
// all derived `pollable`s created with this function are dropped.
extern wasi_io_streams_own_pollable_t wasi_io_streams_method_output_stream_subscribe(wasi_io_streams_borrow_output_stream_t self);
// Write zeroes to a stream.
// 
// This should be used precisely like `write` with the exact same
// preconditions (must use check-write first), but instead of
// passing a list of bytes, you simply pass the number of zero-bytes
// that should be written.
extern bool wasi_io_streams_method_output_stream_write_zeroes(wasi_io_streams_borrow_output_stream_t self, uint64_t len, wasi_io_streams_stream_error_t *err);
// Perform a write of up to 4096 zeroes, and then flush the stream.
// Block until all of these operations are complete, or an error
// occurs.
// 
// This is a convenience wrapper around the use of `check-write`,
// `subscribe`, `write-zeroes`, and `flush`, and is implemented with
// the following pseudo-code:
// 
// ```text
// let pollable = this.subscribe();
// while num_zeroes != 0 {
// // Wait for the stream to become writable
// pollable.block();
// let Ok(n) = this.check-write(); // eliding error handling
// let len = min(n, num_zeroes);
// this.write-zeroes(len);         // eliding error handling
// num_zeroes -= len;
// }
// this.flush();
// // Wait for completion of `flush`
// pollable.block();
// // Check for any errors that arose during `flush`
// let _ = this.check-write();         // eliding error handling
// ```
extern bool wasi_io_streams_method_output_stream_blocking_write_zeroes_and_flush(wasi_io_streams_borrow_output_stream_t self, uint64_t len, wasi_io_streams_stream_error_t *err);
// Read from one stream and write to another.
// 
// The behavior of splice is equivalent to:
// 1. calling `check-write` on the `output-stream`
// 2. calling `read` on the `input-stream` with the smaller of the
// `check-write` permitted length and the `len` provided to `splice`
// 3. calling `write` on the `output-stream` with that read data.
// 
// Any error reported by the call to `check-write`, `read`, or
// `write` ends the splice and reports that error.
// 
// This function returns the number of bytes transferred; it may be less
// than `len`.
extern bool wasi_io_streams_method_output_stream_splice(wasi_io_streams_borrow_output_stream_t self, wasi_io_streams_borrow_input_stream_t src, uint64_t len, uint64_t *ret, wasi_io_streams_stream_error_t *err);
// Read from one stream and write to another, with blocking.
// 
// This is similar to `splice`, except that it blocks until the
// `output-stream` is ready for writing, and the `input-stream`
// is ready for reading, before performing the `splice`.
extern bool wasi_io_streams_method_output_stream_blocking_splice(wasi_io_streams_borrow_output_stream_t self, wasi_io_streams_borrow_input_stream_t src, uint64_t len, uint64_t *ret, wasi_io_streams_stream_error_t *err);

// Imported Functions from `wasi:filesystem/types@0.2.1`
// Return a stream for reading from a file, if available.
// 
// May fail with an error-code describing why the file cannot be read.
// 
// Multiple read, write, and append streams may be active on the same open
// file and they do not interfere with each other.
// 
// Note: This allows using `read-stream`, which is similar to `read` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_read_via_stream(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_filesize_t offset, wasi_filesystem_types_own_input_stream_t *ret, wasi_filesystem_types_error_code_t *err);
// Return a stream for writing to a file, if available.
// 
// May fail with an error-code describing why the file cannot be written.
// 
// Note: This allows using `write-stream`, which is similar to `write` in
// POSIX.
extern bool wasi_filesystem_types_method_descriptor_write_via_stream(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_filesize_t offset, wasi_filesystem_types_own_output_stream_t *ret, wasi_filesystem_types_error_code_t *err);
// Return a stream for appending to a file, if available.
// 
// May fail with an error-code describing why the file cannot be appended.
// 
// Note: This allows using `write-stream`, which is similar to `write` with
// `O_APPEND` in in POSIX.
extern bool wasi_filesystem_types_method_descriptor_append_via_stream(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_own_output_stream_t *ret, wasi_filesystem_types_error_code_t *err);
// Provide file advisory information on a descriptor.
// 
// This is similar to `posix_fadvise` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_advise(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_filesize_t offset, wasi_filesystem_types_filesize_t length, wasi_filesystem_types_advice_t advice, wasi_filesystem_types_error_code_t *err);
// Synchronize the data of a file to disk.
// 
// This function succeeds with no effect if the file descriptor is not
// opened for writing.
// 
// Note: This is similar to `fdatasync` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_sync_data(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_error_code_t *err);
// Get flags associated with a descriptor.
// 
// Note: This returns similar flags to `fcntl(fd, F_GETFL)` in POSIX.
// 
// Note: This returns the value that was the `fs_flags` value returned
// from `fdstat_get` in earlier versions of WASI.
extern bool wasi_filesystem_types_method_descriptor_get_flags(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_descriptor_flags_t *ret, wasi_filesystem_types_error_code_t *err);
// Get the dynamic type of a descriptor.
// 
// Note: This returns the same value as the `type` field of the `fd-stat`
// returned by `stat`, `stat-at` and similar.
// 
// Note: This returns similar flags to the `st_mode & S_IFMT` value provided
// by `fstat` in POSIX.
// 
// Note: This returns the value that was the `fs_filetype` value returned
// from `fdstat_get` in earlier versions of WASI.
extern bool wasi_filesystem_types_method_descriptor_get_type(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_descriptor_type_t *ret, wasi_filesystem_types_error_code_t *err);
// Adjust the size of an open file. If this increases the file's size, the
// extra bytes are filled with zeros.
// 
// Note: This was called `fd_filestat_set_size` in earlier versions of WASI.
extern bool wasi_filesystem_types_method_descriptor_set_size(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_filesize_t size, wasi_filesystem_types_error_code_t *err);
// Adjust the timestamps of an open file or directory.
// 
// Note: This is similar to `futimens` in POSIX.
// 
// Note: This was called `fd_filestat_set_times` in earlier versions of WASI.
extern bool wasi_filesystem_types_method_descriptor_set_times(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_new_timestamp_t *data_access_timestamp, wasi_filesystem_types_new_timestamp_t *data_modification_timestamp, wasi_filesystem_types_error_code_t *err);
// Read from a descriptor, without using and updating the descriptor's offset.
// 
// This function returns a list of bytes containing the data that was
// read, along with a bool which, when true, indicates that the end of the
// file was reached. The returned list will contain up to `length` bytes; it
// may return fewer than requested, if the end of the file is reached or
// if the I/O operation is interrupted.
// 
// In the future, this may change to return a `stream<u8, error-code>`.
// 
// Note: This is similar to `pread` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_read(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_filesize_t length, wasi_filesystem_types_filesize_t offset, llm_tuple2_list_u8_bool_t *ret, wasi_filesystem_types_error_code_t *err);
// Write to a descriptor, without using and updating the descriptor's offset.
// 
// It is valid to write past the end of a file; the file is extended to the
// extent of the write, with bytes between the previous end and the start of
// the write set to zero.
// 
// In the future, this may change to take a `stream<u8, error-code>`.
// 
// Note: This is similar to `pwrite` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_write(wasi_filesystem_types_borrow_descriptor_t self, llm_list_u8_t *buffer, wasi_filesystem_types_filesize_t offset, wasi_filesystem_types_filesize_t *ret, wasi_filesystem_types_error_code_t *err);
// Read directory entries from a directory.
// 
// On filesystems where directories contain entries referring to themselves
// and their parents, often named `.` and `..` respectively, these entries
// are omitted.
// 
// This always returns a new stream which starts at the beginning of the
// directory. Multiple streams may be active on the same directory, and they
// do not interfere with each other.
extern bool wasi_filesystem_types_method_descriptor_read_directory(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_own_directory_entry_stream_t *ret, wasi_filesystem_types_error_code_t *err);
// Synchronize the data and metadata of a file to disk.
// 
// This function succeeds with no effect if the file descriptor is not
// opened for writing.
// 
// Note: This is similar to `fsync` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_sync(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_error_code_t *err);
// Create a directory.
// 
// Note: This is similar to `mkdirat` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_create_directory_at(wasi_filesystem_types_borrow_descriptor_t self, llm_string_t *path, wasi_filesystem_types_error_code_t *err);
// Return the attributes of an open file or directory.
// 
// Note: This is similar to `fstat` in POSIX, except that it does not return
// device and inode information. For testing whether two descriptors refer to
// the same underlying filesystem object, use `is-same-object`. To obtain
// additional data that can be used do determine whether a file has been
// modified, use `metadata-hash`.
// 
// Note: This was called `fd_filestat_get` in earlier versions of WASI.
extern bool wasi_filesystem_types_method_descriptor_stat(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_descriptor_stat_t *ret, wasi_filesystem_types_error_code_t *err);
// Return the attributes of a file or directory.
// 
// Note: This is similar to `fstatat` in POSIX, except that it does not
// return device and inode information. See the `stat` description for a
// discussion of alternatives.
// 
// Note: This was called `path_filestat_get` in earlier versions of WASI.
extern bool wasi_filesystem_types_method_descriptor_stat_at(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_path_flags_t path_flags, llm_string_t *path, wasi_filesystem_types_descriptor_stat_t *ret, wasi_filesystem_types_error_code_t *err);
// Adjust the timestamps of a file or directory.
// 
// Note: This is similar to `utimensat` in POSIX.
// 
// Note: This was called `path_filestat_set_times` in earlier versions of
// WASI.
extern bool wasi_filesystem_types_method_descriptor_set_times_at(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_path_flags_t path_flags, llm_string_t *path, wasi_filesystem_types_new_timestamp_t *data_access_timestamp, wasi_filesystem_types_new_timestamp_t *data_modification_timestamp, wasi_filesystem_types_error_code_t *err);
// Create a hard link.
// 
// Note: This is similar to `linkat` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_link_at(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_path_flags_t old_path_flags, llm_string_t *old_path, wasi_filesystem_types_borrow_descriptor_t new_descriptor, llm_string_t *new_path, wasi_filesystem_types_error_code_t *err);
// Open a file or directory.
// 
// The returned descriptor is not guaranteed to be the lowest-numbered
// descriptor not currently open/ it is randomized to prevent applications
// from depending on making assumptions about indexes, since this is
// error-prone in multi-threaded contexts. The returned descriptor is
// guaranteed to be less than 2**31.
// 
// If `flags` contains `descriptor-flags::mutate-directory`, and the base
// descriptor doesn't have `descriptor-flags::mutate-directory` set,
// `open-at` fails with `error-code::read-only`.
// 
// If `flags` contains `write` or `mutate-directory`, or `open-flags`
// contains `truncate` or `create`, and the base descriptor doesn't have
// `descriptor-flags::mutate-directory` set, `open-at` fails with
// `error-code::read-only`.
// 
// Note: This is similar to `openat` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_open_at(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_path_flags_t path_flags, llm_string_t *path, wasi_filesystem_types_open_flags_t open_flags, wasi_filesystem_types_descriptor_flags_t flags, wasi_filesystem_types_own_descriptor_t *ret, wasi_filesystem_types_error_code_t *err);
// Read the contents of a symbolic link.
// 
// If the contents contain an absolute or rooted path in the underlying
// filesystem, this function fails with `error-code::not-permitted`.
// 
// Note: This is similar to `readlinkat` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_readlink_at(wasi_filesystem_types_borrow_descriptor_t self, llm_string_t *path, llm_string_t *ret, wasi_filesystem_types_error_code_t *err);
// Remove a directory.
// 
// Return `error-code::not-empty` if the directory is not empty.
// 
// Note: This is similar to `unlinkat(fd, path, AT_REMOVEDIR)` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_remove_directory_at(wasi_filesystem_types_borrow_descriptor_t self, llm_string_t *path, wasi_filesystem_types_error_code_t *err);
// Rename a filesystem object.
// 
// Note: This is similar to `renameat` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_rename_at(wasi_filesystem_types_borrow_descriptor_t self, llm_string_t *old_path, wasi_filesystem_types_borrow_descriptor_t new_descriptor, llm_string_t *new_path, wasi_filesystem_types_error_code_t *err);
// Create a symbolic link (also known as a "symlink").
// 
// If `old-path` starts with `/`, the function fails with
// `error-code::not-permitted`.
// 
// Note: This is similar to `symlinkat` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_symlink_at(wasi_filesystem_types_borrow_descriptor_t self, llm_string_t *old_path, llm_string_t *new_path, wasi_filesystem_types_error_code_t *err);
// Unlink a filesystem object that is not a directory.
// 
// Return `error-code::is-directory` if the path refers to a directory.
// Note: This is similar to `unlinkat(fd, path, 0)` in POSIX.
extern bool wasi_filesystem_types_method_descriptor_unlink_file_at(wasi_filesystem_types_borrow_descriptor_t self, llm_string_t *path, wasi_filesystem_types_error_code_t *err);
// Test whether two descriptors refer to the same filesystem object.
// 
// In POSIX, this corresponds to testing whether the two descriptors have the
// same device (`st_dev`) and inode (`st_ino` or `d_ino`) numbers.
// wasi-filesystem does not expose device and inode numbers, so this function
// may be used instead.
extern bool wasi_filesystem_types_method_descriptor_is_same_object(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_borrow_descriptor_t other);
// Return a hash of the metadata associated with a filesystem object referred
// to by a descriptor.
// 
// This returns a hash of the last-modification timestamp and file size, and
// may also include the inode number, device number, birth timestamp, and
// other metadata fields that may change when the file is modified or
// replaced. It may also include a secret value chosen by the
// implementation and not otherwise exposed.
// 
// Implementations are encourated to provide the following properties:
// 
// - If the file is not modified or replaced, the computed hash value should
// usually not change.
// - If the object is modified or replaced, the computed hash value should
// usually change.
// - The inputs to the hash should not be easily computable from the
// computed hash.
// 
// However, none of these is required.
extern bool wasi_filesystem_types_method_descriptor_metadata_hash(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_metadata_hash_value_t *ret, wasi_filesystem_types_error_code_t *err);
// Return a hash of the metadata associated with a filesystem object referred
// to by a directory descriptor and a relative path.
// 
// This performs the same hash computation as `metadata-hash`.
extern bool wasi_filesystem_types_method_descriptor_metadata_hash_at(wasi_filesystem_types_borrow_descriptor_t self, wasi_filesystem_types_path_flags_t path_flags, llm_string_t *path, wasi_filesystem_types_metadata_hash_value_t *ret, wasi_filesystem_types_error_code_t *err);
// Read a single directory entry from a `directory-entry-stream`.
extern bool wasi_filesystem_types_method_directory_entry_stream_read_directory_entry(wasi_filesystem_types_borrow_directory_entry_stream_t self, wasi_filesystem_types_option_directory_entry_t *ret, wasi_filesystem_types_error_code_t *err);
// Attempts to extract a filesystem-related `error-code` from the stream
// `error` provided.
// 
// Stream operations which return `stream-error::last-operation-failed`
// have a payload with more information about the operation that failed.
// This payload can be passed through to this function to see if there's
// filesystem-related information about the error to return.
// 
// Note that this function is fallible because not all stream-related
// errors are filesystem-related errors.
extern bool wasi_filesystem_types_filesystem_error_code(wasi_filesystem_types_borrow_error_t err_, wasi_filesystem_types_error_code_t *ret);

// Imported Functions from `wasi:filesystem/preopens@0.2.1`
// Return the set of preopened directories, and their path.
extern void wasi_filesystem_preopens_get_directories(wasi_filesystem_preopens_list_tuple2_own_descriptor_string_t *ret);

// Imported Functions from `wasi:cli/stdout@0.2.1`
extern wasi_cli_stdout_own_output_stream_t wasi_cli_stdout_get_stdout(void);

// Imported Functions from `wasi:cli/stderr@0.2.1`
extern wasi_cli_stderr_own_output_stream_t wasi_cli_stderr_get_stderr(void);

// Imported Functions from `wasi:cli/stdin@0.2.1`
extern wasi_cli_stdin_own_input_stream_t wasi_cli_stdin_get_stdin(void);

// Imported Functions from `wasi:cli/environment@0.2.1`
// Get the POSIX-style environment variables.
// 
// Each environment variable is provided as a pair of string variable names
// and string value.
// 
// Morally, these are a value import, but until value imports are available
// in the component model, this import function should return the same
// values each time it is called.
extern void wasi_cli_environment_get_environment(llm_list_tuple2_string_string_t *ret);
// Get the POSIX-style arguments to the program.
extern void wasi_cli_environment_get_arguments(llm_list_string_t *ret);
// Return a path that programs should use as their initial current working
// directory, interpreting `.` as shorthand for this.
extern bool wasi_cli_environment_initial_cwd(llm_string_t *ret);

// Imported Functions from `wasi:nn/tensor@0.2.0-rc-2024-08-19`
extern wasi_nn_tensor_own_tensor_t wasi_nn_tensor_constructor_tensor(wasi_nn_tensor_tensor_dimensions_t *dimensions, wasi_nn_tensor_tensor_type_t ty, wasi_nn_tensor_tensor_data_t *data);
// Describe the size of the tensor (e.g., 2x2x2x2 -> [2, 2, 2, 2]). To represent a tensor
// containing a single value, use `[1]` for the tensor dimensions.
extern void wasi_nn_tensor_method_tensor_dimensions(wasi_nn_tensor_borrow_tensor_t self, wasi_nn_tensor_tensor_dimensions_t *ret);
// Describe the type of element in the tensor (e.g., `f32`).
extern wasi_nn_tensor_tensor_type_t wasi_nn_tensor_method_tensor_ty(wasi_nn_tensor_borrow_tensor_t self);
// Return the tensor data.
extern void wasi_nn_tensor_method_tensor_data(wasi_nn_tensor_borrow_tensor_t self, wasi_nn_tensor_tensor_data_t *ret);

// Imported Functions from `wasi:nn/errors@0.2.0-rc-2024-08-19`
// Return the error code.
extern wasi_nn_errors_error_code_t wasi_nn_errors_method_error_code(wasi_nn_errors_borrow_error_t self);
// Errors can propagated with backend specific status through a string value.
extern void wasi_nn_errors_method_error_data(wasi_nn_errors_borrow_error_t self, llm_string_t *ret);

// Imported Functions from `wasi:nn/inference@0.2.0-rc-2024-08-19`
// Define the inputs to use for inference.
extern bool wasi_nn_inference_method_graph_execution_context_set_input(wasi_nn_inference_borrow_graph_execution_context_t self, llm_string_t *name, wasi_nn_inference_own_tensor_t tensor, wasi_nn_inference_own_error_t *err);
// Compute the inference on the given inputs.
// 
// Note the expected sequence of calls: `set-input`, `compute`, `get-output`. TODO: this
// expectation could be removed as a part of
// https://github.com/WebAssembly/wasi-nn/issues/43.
extern bool wasi_nn_inference_method_graph_execution_context_compute(wasi_nn_inference_borrow_graph_execution_context_t self, wasi_nn_inference_own_error_t *err);
// Extract the outputs after inference.
extern bool wasi_nn_inference_method_graph_execution_context_get_output(wasi_nn_inference_borrow_graph_execution_context_t self, llm_string_t *name, wasi_nn_inference_own_tensor_t *ret, wasi_nn_inference_own_error_t *err);

// Imported Functions from `wasi:nn/graph@0.2.0-rc-2024-08-19`
extern bool wasi_nn_graph_method_graph_init_execution_context(wasi_nn_graph_borrow_graph_t self, wasi_nn_graph_own_graph_execution_context_t *ret, wasi_nn_graph_own_error_t *err);
// Load a `graph` from an opaque sequence of bytes to use for inference.
extern bool wasi_nn_graph_load(llm_list_graph_builder_t *builder, wasi_nn_graph_graph_encoding_t encoding, wasi_nn_graph_execution_target_t target, wasi_nn_graph_own_graph_t *ret, wasi_nn_graph_own_error_t *err);
// Load a `graph` by name.
// 
// How the host expects the names to be passed and how it stores the graphs for retrieval via
// this function is **implementation-specific**. This allows hosts to choose name schemes that
// range from simple to complex (e.g., URLs?) and caching mechanisms of various kinds.
extern bool wasi_nn_graph_load_by_name(llm_string_t *name, wasi_nn_graph_own_graph_t *ret, wasi_nn_graph_own_error_t *err);

// Exported Functions from `wasi:cli/run@0.2.1`
bool exports_wasi_cli_run_run(void);

// Helper Functions

extern void wasi_io_poll_pollable_drop_own(wasi_io_poll_own_pollable_t handle);

extern wasi_io_poll_borrow_pollable_t wasi_io_poll_borrow_pollable(wasi_io_poll_own_pollable_t handle);

void wasi_io_poll_list_borrow_pollable_free(wasi_io_poll_list_borrow_pollable_t *ptr);

void llm_list_u32_free(llm_list_u32_t *ptr);

void llm_list_u8_free(llm_list_u8_t *ptr);

extern void wasi_io_error_error_drop_own(wasi_io_error_own_error_t handle);

extern wasi_io_error_borrow_error_t wasi_io_error_borrow_error(wasi_io_error_own_error_t handle);

void wasi_io_streams_stream_error_free(wasi_io_streams_stream_error_t *ptr);

extern void wasi_io_streams_input_stream_drop_own(wasi_io_streams_own_input_stream_t handle);

extern wasi_io_streams_borrow_input_stream_t wasi_io_streams_borrow_input_stream(wasi_io_streams_own_input_stream_t handle);

extern void wasi_io_streams_output_stream_drop_own(wasi_io_streams_own_output_stream_t handle);

extern wasi_io_streams_borrow_output_stream_t wasi_io_streams_borrow_output_stream(wasi_io_streams_own_output_stream_t handle);

void wasi_io_streams_result_list_u8_stream_error_free(wasi_io_streams_result_list_u8_stream_error_t *ptr);

void wasi_io_streams_result_u64_stream_error_free(wasi_io_streams_result_u64_stream_error_t *ptr);

void wasi_io_streams_result_void_stream_error_free(wasi_io_streams_result_void_stream_error_t *ptr);

void wasi_filesystem_types_option_datetime_free(wasi_filesystem_types_option_datetime_t *ptr);

void wasi_filesystem_types_descriptor_stat_free(wasi_filesystem_types_descriptor_stat_t *ptr);

void wasi_filesystem_types_new_timestamp_free(wasi_filesystem_types_new_timestamp_t *ptr);

void wasi_filesystem_types_directory_entry_free(wasi_filesystem_types_directory_entry_t *ptr);

extern void wasi_filesystem_types_descriptor_drop_own(wasi_filesystem_types_own_descriptor_t handle);

extern wasi_filesystem_types_borrow_descriptor_t wasi_filesystem_types_borrow_descriptor(wasi_filesystem_types_own_descriptor_t handle);

extern void wasi_filesystem_types_directory_entry_stream_drop_own(wasi_filesystem_types_own_directory_entry_stream_t handle);

extern wasi_filesystem_types_borrow_directory_entry_stream_t wasi_filesystem_types_borrow_directory_entry_stream(wasi_filesystem_types_own_directory_entry_stream_t handle);

void wasi_filesystem_types_result_own_input_stream_error_code_free(wasi_filesystem_types_result_own_input_stream_error_code_t *ptr);

void wasi_filesystem_types_result_own_output_stream_error_code_free(wasi_filesystem_types_result_own_output_stream_error_code_t *ptr);

void wasi_filesystem_types_result_void_error_code_free(wasi_filesystem_types_result_void_error_code_t *ptr);

void wasi_filesystem_types_result_descriptor_flags_error_code_free(wasi_filesystem_types_result_descriptor_flags_error_code_t *ptr);

void wasi_filesystem_types_result_descriptor_type_error_code_free(wasi_filesystem_types_result_descriptor_type_error_code_t *ptr);

void wasi_filesystem_types_result_tuple2_list_u8_bool_error_code_free(wasi_filesystem_types_result_tuple2_list_u8_bool_error_code_t *ptr);

void wasi_filesystem_types_result_filesize_error_code_free(wasi_filesystem_types_result_filesize_error_code_t *ptr);

void wasi_filesystem_types_result_own_directory_entry_stream_error_code_free(wasi_filesystem_types_result_own_directory_entry_stream_error_code_t *ptr);

void wasi_filesystem_types_result_descriptor_stat_error_code_free(wasi_filesystem_types_result_descriptor_stat_error_code_t *ptr);

void wasi_filesystem_types_result_own_descriptor_error_code_free(wasi_filesystem_types_result_own_descriptor_error_code_t *ptr);

void wasi_filesystem_types_result_string_error_code_free(wasi_filesystem_types_result_string_error_code_t *ptr);

void wasi_filesystem_types_result_metadata_hash_value_error_code_free(wasi_filesystem_types_result_metadata_hash_value_error_code_t *ptr);

void wasi_filesystem_types_option_directory_entry_free(wasi_filesystem_types_option_directory_entry_t *ptr);

void wasi_filesystem_types_result_option_directory_entry_error_code_free(wasi_filesystem_types_result_option_directory_entry_error_code_t *ptr);

void wasi_filesystem_types_option_error_code_free(wasi_filesystem_types_option_error_code_t *ptr);

void wasi_filesystem_preopens_tuple2_own_descriptor_string_free(wasi_filesystem_preopens_tuple2_own_descriptor_string_t *ptr);

void wasi_filesystem_preopens_list_tuple2_own_descriptor_string_free(wasi_filesystem_preopens_list_tuple2_own_descriptor_string_t *ptr);

void llm_tuple2_string_string_free(llm_tuple2_string_string_t *ptr);

void llm_list_tuple2_string_string_free(llm_list_tuple2_string_string_t *ptr);

void llm_list_string_free(llm_list_string_t *ptr);

void llm_option_string_free(llm_option_string_t *ptr);

void wasi_nn_tensor_tensor_dimensions_free(wasi_nn_tensor_tensor_dimensions_t *ptr);

void wasi_nn_tensor_tensor_data_free(wasi_nn_tensor_tensor_data_t *ptr);

extern void wasi_nn_tensor_tensor_drop_own(wasi_nn_tensor_own_tensor_t handle);

extern wasi_nn_tensor_borrow_tensor_t wasi_nn_tensor_borrow_tensor(wasi_nn_tensor_own_tensor_t handle);

extern void wasi_nn_errors_error_drop_own(wasi_nn_errors_own_error_t handle);

extern wasi_nn_errors_borrow_error_t wasi_nn_errors_borrow_error(wasi_nn_errors_own_error_t handle);

void wasi_nn_inference_tensor_data_free(wasi_nn_inference_tensor_data_t *ptr);

extern void wasi_nn_inference_graph_execution_context_drop_own(wasi_nn_inference_own_graph_execution_context_t handle);

extern wasi_nn_inference_borrow_graph_execution_context_t wasi_nn_inference_borrow_graph_execution_context(wasi_nn_inference_own_graph_execution_context_t handle);

void wasi_nn_inference_result_void_own_error_free(wasi_nn_inference_result_void_own_error_t *ptr);

void wasi_nn_inference_result_own_tensor_own_error_free(wasi_nn_inference_result_own_tensor_own_error_t *ptr);

extern void wasi_nn_graph_graph_drop_own(wasi_nn_graph_own_graph_t handle);

extern wasi_nn_graph_borrow_graph_t wasi_nn_graph_borrow_graph(wasi_nn_graph_own_graph_t handle);

void wasi_nn_graph_graph_builder_free(wasi_nn_graph_graph_builder_t *ptr);

void wasi_nn_graph_result_own_graph_execution_context_own_error_free(wasi_nn_graph_result_own_graph_execution_context_own_error_t *ptr);

void llm_list_graph_builder_free(llm_list_graph_builder_t *ptr);

void wasi_nn_graph_result_own_graph_own_error_free(wasi_nn_graph_result_own_graph_own_error_t *ptr);

void exports_wasi_cli_run_result_void_void_free(exports_wasi_cli_run_result_void_void_t *ptr);

// Transfers ownership of `s` into the string `ret`
void llm_string_set(llm_string_t *ret, const char*s);

// Creates a copy of the input nul-terminate string `s` and
// stores it into the component model string `ret`.
void llm_string_dup(llm_string_t *ret, const char*s);

// Deallocates the string pointed to by `ret`, deallocating
// the memory behind the string.
void llm_string_free(llm_string_t *ret);

#ifdef __cplusplus
}
#endif
#endif
